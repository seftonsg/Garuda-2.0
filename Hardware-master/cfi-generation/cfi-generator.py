#!/usr/bin/env python3

import sys
import subprocess

def main(binary):
  # Run bap on the provided binary, and remove the first 5 lines
  lines = subprocess.getoutput("bap " + binary + " -d --print-symbol=main")
  lines = lines.split('\n')
  lines = lines[5:]
  
  nodes = build_cfg(lines)
  ids = build_ids(nodes)
  build_cfi(nodes, ids)

# This function builds list of nodes and returns the completed list to main
# It takes the IR from bap as the input
def build_cfg(lines):
  build_node = []
  nodes = []

  for line in lines:
    # Clean up lines so they are readable
    line = line.strip('\n')
    # If the line is empty (no instruction) then a node has ended
    # If a node has been built, add it to the list of nodes
    if not line and build_node:
      nodes.append(build_node)
      build_node = []
    # If the line has an instruction then add it to the current node
    elif line:
      build_node.append(line)

  return build_nodes(nodes)

# This function returns a list of nodes
# It is a helper function for build_cfg
# It takes a list of the nodes built by build_cfg as an argument
# A finished node has the form
# [name, entrance-addr, [(exit-addr1, exit-target1), ...], [pred1, ...], [succ1, ...], id-num]
def build_nodes(node_list):
  nodes = []

  # Extract the memory addresses for each node, node entrance, and node exit
  counter = 0
  for node in node_list:
    exits = []

    # Node names initially exist in the form of 'xxxxxxxx: ' where 'x' is a hex value
    name = "node" + str(counter)

    # Separate the instruction from the address of the entrance, and store only the entrance
    entrance = node[0]
    entrance = entrance.split()[0]
    entrance = entrance[:-1]

    # Iterate through every instruction in the node and extract the address for any line that contains a jump or branch
    for instr in node:
      if 'goto' in instr or 'call' in instr or 'return' in instr:
        if 'RA' in instr:
          exit = (instr.split()[0][:-1], instr.split()[-1])
        else:
          exit = (instr.split()[0][:-1], instr.split()[-1][1:])
        exits.append(exit)

    # Add the node name, entrance, and a list of exits to a list of all nodes
    nodes.append([name, entrance, exits, [], [], counter])
    counter += 1

  # Populates list of direct successors in the list
  for index, node in enumerate(nodes):
    remaining = nodes[index+1:]
    for nextnode in remaining:
      for exitpoint in node[2]:
        if nextnode[1] in exitpoint[-1]:
          node[-2].append(nextnode[0])

  # Populates list of direct predecessors in the list
  for node1 in nodes:
    for node2 in nodes:
      if node2[0] in node1[-2]:
        node2[-3].append(node1[0])

  return nodes

# This function builds list of ids for CFI
# It takes this list of nodes generated by build_cfg as an argument and returns the list of ids
# This is not the final implementation, and exists just as a place holder
def build_ids(nodes):
  ids = [[nodes[0][0]]]
  for index, node1 in enumerate(nodes):
    if node1[-1] and node1[-1] not in ids:
      ids.append(node1[-1])

  return ids

# This function generates cfi.v based on the information from bap
def build_cfi(node_components, ids):
  nodes = []

  # Opens a file with the necessary imports and header for the CFI section and stores it as a string.
  with open("cfi-header.txt", "r") as f:
    cfi_header = f.read()

  f = open('../src/cfi.v', 'w')
  f.write(cfi_header)

  # Builds a list of the nodes, to be stored as an integer by cfi.v
  for node in node_components:
    # The list of nodes used in cfi.v currently only uses the entrance for nodes w/o an exit
    # This may not be the ideal solution
    node_start = node[1]
    node_start = str(int(node_start, 16))
    if node[2]:
      node_end = node[2][-1][0]
      node_end = str(int(node_end, 16))
      nodes.append((node[0], node_start + node_end))
    else:
      nodes.append((node[0], node_start))

  # Writes the list of nodes to cfi.v
  for node in nodes:
    f.write("  Definition " + node[0] + " := Int64.repr " + node[1] + ".\n")

  write_cfi_logic(node_components, nodes, ids, f)

  f.write("End CFI.\n")
  f.close()

# This function builds the logic for the CFI and writes it to ../src/cfi.v
# It is a helper function for build_cfi
# It takes the list of nodes generated by build_cfg, the node names generated in build_cfi,
## the ids, and the file opened in build_cfi as arguments
def write_cfi_logic(node_components, nodes, ids, f):
  # Writes CFI logic to ../src/cfi.v
  f.write("  Definition cfi : pol :=\n")
  f.write("    PId.\n")

  '''
  # START DEBUG
  # Prints comments in cfi.v with node info for debug purposes
  f.write("(* CFI DEBUG INFO\n")
  for node in node_components:
    f.write(str(node[-1]) + '\n')
  f.write("IDS\n")
  for node in ids:
    f.write(str(node) + '\n')
  f.write(" END CFI DEBUG INFO *)\n")
  # END DEBUG
  '''

# This function prints out the usage syntax if the user does not provide an argument
def usage():
  print("Usage:\n" + str(sys.argv[0]) + " <Mips Binary>")

if __name__ == "__main__":
  if len(sys.argv) != 2:
    usage()
  else:
    main(sys.argv[1])
